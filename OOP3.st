TestCase subclass: #ExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ExampleTest methodsFor: 'as yet unclassified' stamp: 'NM 11/30/2015 17:15'!setUp	(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].	(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].	MyObject subclass: #A		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.
	A subclass: #B 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.! !!ExampleTest methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 22:45'!testExample|temp|self halt.	A compile: 'foo		^1	"@Private"'.	A compile: 'bar	^2'.		self assert: ((B classCanUnderstand: #foo) = false).	self assert: ((B new instRespondsTo: #foo) = false).	self assert: ((B classCanUnderstand: #bar) = true).	self assert: ((B new instRespondsTo: #bar) = true).	temp := false.	[		B compile: 'bar		^3'	] on: AssertionFailure do:	[:e|		temp := true.		self assert:(e messageText = 'Method already exists!!').	].	self assert: (temp = true).	temp := false.	[		B compile: 'moo		^4 "@Abstract" "@Final"'	] on: AssertionFailure do:	[:e|		temp := true.		self assert:(e messageText = 'Bad Tags!!').	].	self assert: (temp = true).! !TestCase subclass: #GuyOmerTestsEX3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!GuyOmerTestsEX3 methodsFor: 'initialize-release' stamp: 'guy 5/8/2017 15:36'!setUp	(Smalltalk hasClassNamed: #MyObject) ifTrue: [Smalltalk removeClassNamed: #Tywin].	(Smalltalk hasClassNamed: #Tywin) ifTrue: [Smalltalk removeClassNamed: #Cersei].	(Smalltalk hasClassNamed: #Cersei) ifTrue: [Smalltalk removeClassNamed: #Tommen].	MyObject subclass: #Tywin		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	Tywin subclass: #Cersei 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	Cersei subclass: #Tommen 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.! !!GuyOmerTestsEX3 methodsFor: 'aux - methods' stamp: 'guy 5/10/2017 07:46'!removeAllLannisterSelectors	"Removes all the selectors if all the classes for the test"		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tywin.	GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tommen.! !!GuyOmerTestsEX3 methodsFor: 'aux - methods' stamp: 'guy 5/10/2017 07:43'!removeAllSelectorsOfClass: aClass	"Given a class, this methods removes all the selectors in class' method dictionary"	(aClass selectors) do: [:s | aClass removeSelector: s].! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:09'!test1GetTags	| fTywin fCersei hCersei hTommen fCerseiTags hCerseiTags hTommenTags gTywin gTywinTags iTommen jTommen kTommen |	fTywin := 'f	"@Private is not public"	Transcript show: ''f''.'.	fCersei := 'f	"@Override"	Transcript show: ''f''.'.	hCersei := 'h	Transcript show: 3. "@N ew"	^ true.	"@RetType: Boolean"'.	hTommen := 'h	Transcript show: 3. "@New"	^ true.	"@RetType: Boolean"'.	gTywin :='g: x and: y	"@Private" Transcript show: x; show: y.	"@ArgsTypes: SmallInteger, SmallInteger."'.	iTommen := 'i	Transcript show: ''i''. "@Fi	nal"'.	jTommen := 'j	"I am not a @Private method"'.	kTommen := 'k	Transcript show: 5. "@new" "(lowercase)"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: fTywin.	self assert: ((Tywin getTags: fTywin) size = 0). "No tags"	fCerseiTags := Set new.  fCerseiTags add: 'Override'.	Cersei compile: fCersei.	self assert:((Cersei getTags: fCersei) =  fCerseiTags). "Tags: Override"	hCerseiTags := Set new.  hCerseiTags add: 'RetType'.	Cersei compile: hCersei.	self assert:((Cersei getTags: hCersei) =  hCerseiTags).  "Tags: RetType"	hTommenTags := Set new.  hTommenTags add: 'New'. hTommenTags add: 'RetType'.	Tommen compile: hTommen.	self assert:((Tommen getTags: hTommen) =  hTommenTags).  "Tags: RetType , New"	gTywinTags := Set new.  gTywinTags add: 'ArgsTypes'. gTywinTags add: 'Private'.	Tywin compile: gTywin.	self assert:((Tywin getTags: gTywin) =  gTywinTags).  "Tags: Private , ArgsTypes"	Tommen compile: iTommen.	self assert:((Tommen getTags: iTommen) size = 0).  "No Tags"	Tommen compile: jTommen.	self assert:((Tommen getTags: jTommen) size =  0).  "No Tags"	Tommen compile: kTommen.	self assert:((Tommen getTags: kTommen) size =  0).  "No Tags"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 22:18'!test2CheckArgsTypes	| gTywin isException funTommen |	gTywin :='g: x and: y			 	 	 	| privy |	"@NOT Private" ^(x*y). "@NOTRetType: Number"	"@ArgsTypes: SmallInteger, SmallInteger."'.		funTommen :='fun: aCat with: aNumber 	"@Final" 	"@ArgsTypes: ByteString, Integer."	"@NOTRetType: String" ^''Ser Pounce'''.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: gTywin.	isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.			isException := false.	[(Tywin new) g: 7 and: 'hells'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.		isException := false.	[(Tywin new) g: 'Winter' and: 'is coming'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: funTommen.		isException := false.	[(Tommen new) fun: 'cat of the canals' with: 7] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.		isException := false.	[(Tommen new) fun: 'cat of the canals' with: 'Not a number thou'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.		isException := false.	[(Tommen new) fun: 'A' with: 'Still not a number'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 22:06'!test3CheckRetType	| gTywin isException funTommen omgTywin |	gTywin :='g: x and: y	| privy |	"@NOPrivate" ^(x*y). "@RetType: Number."	"@ArgsTypes: SmallInteger, SmallInteger."'.		omgTywin :='g: x and: y	| privy |	"@NOPrivate" ^(x*y). "@RetType: String."	"@ArgsTypes: SmallInteger, SmallInteger."'.		funTommen :='fun: aCat with: aNumber 	"@Final" 		"@ArgsTypes: ByteString, Integer."	"@RetType: String." ^''Ser Pounce'''.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: gTywin.		isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | "Should not throw exception"	isException := true.].	self assert: isException not.		Tywin compile: omgTywin.	isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: funTommen.	isException := false.	[(Tommen new) fun: 'cat of the canals' with: 7] on: AssertionFailure do:[ :e | "Should not throw exception"	isException := true.].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:54'!test4IsMethodAbstractIn	| hMethodAbstract hMethodNotAbstractOverride hMethodAbstractOverride hMethodNotAbstract |	hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractOverride := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean.""@Override"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: hMethodAbstract.	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Tywin"	self assert: (MyObject isMethod: #'h' abstractIn: Tommen). "Abstract in Tywin"	Cersei compile: hMethodNotAbstractOverride.	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	self assert: ((MyObject isMethod: #'h' abstractIn: Cersei) not). "Not Abstract in Cersei"	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Cersei"	Tommen compile: hMethodNotAbstractOverride.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen"	self assert: ((MyObject isMethod: #'h' abstractIn: Cersei) not). "Not Abstract in Cersei"	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	Cersei compile: hMethodAbstractOverride.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen - Tommen overrides Cersei's method"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Cersei"	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	Tywin compile: hMethodNotAbstract.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen - Tommen overrides Cersei's method"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Cersei"	self assert: ((MyObject isMethod: #'h' abstractIn: Tywin) not). "Not Abstract in Tywin"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 23:05'!test5IsAbstractClass	| hMethodAbstract hMethodNotAbstractOverride hMethodAbstractOverride hMethodNotAbstract chickenMethodNotAbstract chickenMethodNotAbstractOverride |		chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractOverride := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean.""@Override"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: hMethodAbstract.	Tywin compile: chickenMethodNotAbstract.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Tommen). "Abstract because Tywin has an abstract method"	Cersei compile: hMethodNotAbstractOverride.	Cersei compile: chickenMethodNotAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	Tommen compile: hMethodNotAbstractOverride.	Tommen compile: chickenMethodNotAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Cersei compile: hMethodAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Cersei has an abstract method"	self assert: ((MyObject isAbstractClass: Tommen) not). "Abstract because Cersei has an abstract method"	Tywin compile: hMethodNotAbstract.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has not abstract methods"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Cersei has an abstract method"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Cersei compile: hMethodNotAbstractOverride.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has not abstract methods"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden with 'Abstract' methods"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Tommen compile: hMethodAbstractOverride.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has no abstract methods"	self assert: ((MyObject isAbstractClass: Cersei) not). "Abstract because Cersei has an abstract method"	self assert: (MyObject isAbstractClass: Tommen). "Abstract because Tommen has an abstract method"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:11'!test6CheckError1	| isException abadiTommen oreoCersei lotusTywin |		abadiTommen := 'abadi	Transcript show: ''abadi is love''. "@Final"			"@Abstract"'.		oreoCersei := 'oreo	"@Override"	Transcript show: ''f''.	Transcript show: 3. "@New"		^ true.	"@RetType: Boolean"'.	lotusTywin := 'lutus	"@Override"	"@Private"	"@Private is not public"	Transcript show: ''f''.'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tommen compile: abadiTommen] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Final + Abstract - DAS IST NICHT GUT"	self assert: isException.		isException := false.	[Cersei compile: oreoCersei] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Override + New - DAS IST NICHT GUT"	self assert: isException.		isException := false.	[Tywin compile: lotusTywin] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Override + Private - DAS IST NICHT GUT"	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:55'!test7CheckError9	| abadiMethodNotAbstract isException abadiMethodAbstract aTywin |	abadiMethodAbstract := 'abadi: please	| sum |	"@Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.		abadiMethodNotAbstract := 'abadi: please with: extraPlease	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[aTywin := Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.		Tywin compile: abadiMethodAbstract.		isException := false.	[aTywin abadi: 1984] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Abstract method called!!')]. "This method is 'Abstract' - exception9 should be thrown"	self assert: isException.		Tywin compile: abadiMethodNotAbstract.		isException := false.	[aTywin abadi: 'drink' with: 'things'] on: AssertionFailure do:[ :e | "This method is NOT 'Abstract' - exception9 should NOT be thrown"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:55'!test8CheckError7	| abadiMethodNotAbstract isException abadiMethodAbstract aTywin abadiWithMethodNotAbstract |	abadiMethodAbstract := 'abadi: please	| sum |	"@Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.		abadiMethodNotAbstract := 'abadi: please	| sum |	"@NOT Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.	abadiWithMethodNotAbstract := 'abadi: please with: extraPlease	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[aTywin := Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.		Tywin compile: abadiMethodAbstract.		isException := false.	[(Tywin new) abadi: 1984] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "Tywin class is 'Abstract' - exception7 should be thrown"	self assert: isException.		Tywin compile: abadiWithMethodNotAbstract.		isException := false.	[(Tywin new) abadi: 1984 with: 'chicken'] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "Tywin class is still 'Abstract' - exception7 should be thrown"	self assert: isException.	Tywin compile: abadiMethodNotAbstract. "Now Tywin class is NOT 'Abstract' "		isException := false.	[Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:12'!test9CheckError8	| chickenMethodPrivate methodSymbol isException chickenMethodNotPrivate hMethodNotPrivate hMethodNotPrivateNew chickenMethodPrivateNew |		hMethodNotPrivate := 'h: x	"@NOT Private"	"I''m a private method"	^(self checkChicken: 1 nevermind: 2 knowwhat: 3) "@Calls checkChicken method"   '.		hMethodNotPrivateNew := 'h: x	"@NOT Private" "@New"	"I''m a private method andalso a new one"	^(self checkChicken: 1 nevermind: 2 knowwhat: 3) "@Calls checkChicken method"   '.		chickenMethodNotPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Private at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.	chickenMethodPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Private" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@NOT New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	methodSymbol :=#'checkChicken:nevermind:knowwhat:'.	Tywin compile: chickenMethodNotPrivate.	Tywin compile: hMethodNotPrivate.	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodPrivate. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.		"------------------------------------------------------------------------------------------------------------------"	Cersei compile: chickenMethodPrivateNew. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: chickenMethodPrivateNew. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:13'!test_10classCanUnderstand	| chickenMethodNotAbstract chickenMethodNotAbstractOverride chickenMethodAbstract methodSymbol chickenMethodAbstractOverride chickenMethodNotAbstractPrivate chickenMethodNotAbstractPrivateNew chickenMethodNotAbstractNotPrivateNew chickenMethodAbstractNew |	chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodAbstractNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.		chickenMethodNotAbstractNotPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@NOT Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	methodSymbol :=#'checkChicken:nevermind:knowwhat:'.		"checkChicken does not exist"	Tywin compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).		Tywin compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Cersei compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).		Cersei compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tommen compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol).		Tommen compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tywin compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol) not. "Because 'Private'"	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because 'Private'"	Tywin removeSelector: methodSymbol.	Cersei compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because 'Private'"	Cersei removeSelector: methodSymbol.	Tommen compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tywin compile: chickenMethodNotAbstractPrivate.	Cersei compile: chickenMethodNotAbstractNotPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol). "Tommen understands because Cersei has 'New' tag"	Cersei compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	Tommen compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).	Tywin compile: chickenMethodNotAbstract.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol). 	self assert: (Tommen classCanUnderstand: methodSymbol). "Because Cersei has this method as 'Private' (the 'New' does not affect here) "		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tywin.	Tommen compile: chickenMethodAbstractNew.	self assert: ((Tywin classCanUnderstand: methodSymbol) not).	self assert: (Cersei classCanUnderstand: methodSymbol). 	self assert: ((Tommen classCanUnderstand: methodSymbol) not). "Because Cersei has this method as 'Private' (the 'New' does not affect here) and Tywin does not have this method at all"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 23:06'!test_11InstRespondsTo	| chickenMethodNotAbstract chickenMethodNotAbstractOverride chickenMethodAbstract methodSymbol chickenMethodAbstractOverride chickenMethodNotAbstractPrivate chickenMethodNotAbstractPrivateNew chickenMethodNotAbstractNotPrivateNew chickenMethodAbstractNew |	chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.	chickenMethodAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodAbstractNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.	chickenMethodAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.		chickenMethodNotAbstractNotPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@NOT Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"		methodSymbol :=#'checkChicken:nevermind:knowwhat:'.	"checkChicken does not exist"	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol) not.		Tywin compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Cersei compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol) not. "Because 'Private'"	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because 'Private'"	Tywin removeSelector: methodSymbol.	Cersei compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because 'Private'"	Cersei removeSelector: methodSymbol.	Tommen compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodNotAbstractPrivate.	Cersei compile: chickenMethodNotAbstractNotPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol). "Tommen understands because Cersei has 'New' tag"	Cersei compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	Tommen compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).	Tywin compile: chickenMethodNotAbstract.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol). 	self assert: (Tommen new instRespondsTo: methodSymbol). "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:56'!test_12CheckError2	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew |		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method already exists!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method already exists!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:57'!test_13CheckError3	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew |		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		Tywin removeSelector: #'h'.	Cersei removeSelector: #'h'.	Tommen removeSelector: #'h'.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:57'!test_14CheckError4	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew hMethodAbstract hMethodAbstractNew |		hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractNew := 'h	| sum |	"@Abstract"	sum := 5.	"@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"4.1-------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - 'New' works on superclasses"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Cersei has no implementation (Abstract)"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception - no 'New' "	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception - Cersei has an implementation"	Transcript show: e;cr.	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception - Tywin has NOT Abstract "	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Cersei has no implementation at all"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.	"4.2-------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should throw exception - Tommen uses 'New' so Tywin can not use 'Abstract' "	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Tommen uses 'New' so Cersei can not use 'Abstract' "	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception - Cersei has actual implementation"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 23:07'!test_15CheckError5	|  hMethodNew hMethodNotPrivate hMethodNotPrivateNew hMethodOverride hMethodPrivate hMethodPrivateNew isException |		hMethodPrivate := 'h	| sum |	"@Private"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotPrivate := 'h	| sum |	"@NOT Private"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodPrivateNew := 'h	| sum |	"@Private"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotPrivateNew := 'h	| sum |	"@NOT Private"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNew:= 'h	| sum |	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.			hMethodOverride:= 'h	| sum |	"@Override"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"5.1-------------------------------------------------------------------------------------------------------------"		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	GuyOmerTestsEX3 new removeAllLannisterSelectors.	"5.2-----------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:58'!test_16CheckError6	|  hMethodNew hMethodNotFinal hMethodNotFinalNew hMethodOverride hMethodFinal hMethodFinalNew isException |		hMethodFinal := 'h	| sum |	"@Final"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotFinal := 'h	| sum |	"@NOT Final"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodFinalNew := 'h	| sum |	"@Final"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotFinalNew := 'h	| sum |	"@NOT Final"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNew:= 'h	| sum |	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodOverride:= 'h	| sum |	"@Override"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"6.1-------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"6.2-------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:17'!test_17AnotheRule	|   isException  kallllMethodAbstract kallllMethodOverride kallllMethod |	kallllMethod:= 'kallll	| sum |	"@Fork off"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.		kallllMethodAbstract := 'kallll	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.		kallllMethodOverride := 'kallll	| sum |	"@Override"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: kallllMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: kallllMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - no classes below"		isException := false.	[Tywin compile: kallllMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - Tommen has '@Override' "		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tommen compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - Tommen has '@Override' "		isException := false.	[Cersei compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Tommen has has nothing "		isException := false.	[Cersei compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Cersei sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - because why should it ? "	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Tommen had no tags before compilation "		isException := false.	[Tywin compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Cersei sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Cersei had no tags before compilation "	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should still contain tag 'New'  "	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !Class subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'private' stamp: 'initalize 5/23/2017 20:25'!instRespondsTo: aSymbol^ ((self class) classCanUnderstand:aSymbol).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: ''!!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/24/2017 20:27'!changeToAbstract:original|result|result := ''.(ReadStream on: original) do: [ :currentChar | 	result:=result,currentChar.	(currentChar=Character cr) ifTrue:[		result:=result,'MyObject throwAbstractMethodInvoked.'.		(self getTags:original) do:[:tag | result:=result,'"@',tag,'"'].		^result]	].! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/25/2017 08:10'!isMethod: aSymbol abstractIn: aClass
	"The method return true if the symbol which represent a method is an abstract method, and false otherwise"	| aSuperclass tagSet|	 aSuperclass := aClass.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false].	  [self isEndOfHierachy:aSuperclass]		whileFalse: 			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Abstract') ifTrue:[^true].			(tagSet includes:'Override') ifTrue:[^false]].			aSuperclass := aSuperclass superclass].	^false.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/25/2017 08:27'!isMethod: aSymbol finalIn: aClass	^ self isMethod: aSymbol in: aClass collidWith: 'Final' and: 'New'.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/25/2017 08:28'!isMethod: aSymbol in: aClass collidWith: firstAnnotation and: secondAnnotation
	"The method return true if the symbol which represent a method is a private method, and false otherwise"	| aSuperclass tagSet|	 aSuperclass := aClass.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false].	  [self isEndOfHierachy:aSuperclass]		whileFalse: 			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes: firstAnnotation) ifTrue:[^true].			(tagSet includes: secondAnnotation) ifTrue:[^false]].			aSuperclass := aSuperclass superclass].	^false.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/25/2017 08:26'!isMethod: aSymbol privateIn: aClass
	"The method return true if the symbol which represent a method is a private method, and false otherwise"	^ self isMethod: aSymbol in: aClass collidWith: 'Private' and: 'New'.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/23/2017 12:25'!new	(MyObject isAbstractClass:(self)) ifTrue:[self throwCanNotInitAbstract].	^(super new).! !!MyObject class methodsFor: 'TagsHelper' stamp: 'rj 5/19/2017 18:27'!char:ch existOnLine:line in:aString	"the method return a boolean if  ch exist on line in aString"	|lineNumber hadBeenCommented |	lineNumber:=1.	(ReadStream on: aString) do: [ :currentChar | 	(lineNumber=line and:[currentChar=ch ]) ifTrue:[ ^(hadBeenCommented:=true) ].	(lineNumber>line) ifTrue:[^false].	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"	^false.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'rj 5/19/2017 16:53'!extractTagContent: aTag
	"the method get aTag for example @SomeTag and return SomeTag"
	|tagSize tagContent|
	tagSize:= (aTag size).
	tagContent:= aTag copyFrom: 3 to: tagSize-1.
	^tagContent.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'initalize 5/24/2017 22:59'!findChar:ch in:aString	"the method return a the line number which ch first appears in aString"	|lineNumber stringArray|	lineNumber:=1.	stringArray := aString lines.	stringArray do:[:line| 		(((line asString) findString:(ch asString)) >0 ) ifTrue:[^lineNumber]. 		lineNumber:=lineNumber+1.].	"(ReadStream on: aString) do: [ :currentChar | 	(currentChar=ch ) ifTrue:[ ^lineNumber ].	(currentChar=Character cr |  currentChar=Character lf) ifTrue:[lineNumber :=  lineNumber+1].	].""end of do block"	^-1.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'initalize 5/24/2017 23:19'!getTags:aString"a class method that get a String and returns a set of all the tags in that String without any special symbols, if no tags 	where found an empty Set is returned""example of such set will be:   {'New','Final','ArgsType'}"|SetToReturn realString|SetToReturn := Set new.realString:=(aString asString).((realString findString: '"@New"') > 0) ifTrue: [SetToReturn add:'New'].((realString findString: '"@Final"') > 0) ifTrue: [SetToReturn add:'Final'].((realString findString: '"@Override"') > 0) ifTrue: [SetToReturn add:'Override'].((realString findString: '"@Private"') > 0) ifTrue: [SetToReturn add:'Private'].((realString findString: '"@Abstract"') > 0) ifTrue: [SetToReturn add:'Abstract'].((realString findString: '"@RetType:') > 0) ifTrue: [SetToReturn add:'RetType'].((realString findString: '"@ArgsTypes:') > 0) ifTrue: [SetToReturn add:'ArgsTypes'].^SetToReturn.! !!MyObject class methodsFor: 'Private' stamp: 'initalize 5/24/2017 20:27'!addPrivateCheck:methodText"the method inject privacy check to methodText"| toInject result parser methodName|	parser:= Parser new.	methodName:=parser parseSelector:methodText.		toInject:='			(			(	(thisContext client) class	)  includesLocalSelector: (#',methodName,')		)		 ifFalse:[			MyObject throwCanNotAccessMethod.			].'.			result:= self inject:toInject toMethod:methodText.		^result.! !!MyObject class methodsFor: 'Private' stamp: 'initalize 5/25/2017 08:12'!classCanUnderstand: aSymbol	| aSuperclass tagSet|	 aSuperclass := self.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false]. "RULE #1"	(MyObject isMethod:aSymbol abstractIn:self) ifTrue:[^false]. "RULE #2"	(aSuperclass includesSelector:aSymbol) ifTrue:[tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).	(tagSet includes:'Private') ifTrue:[^true]].  "part 2 of RULE #3"	 [self isEndOfHierachy:aSuperclass]		whileFalse: "Part 1+3 of RULE #3"			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Private') ifTrue:[^false].			(tagSet includes:'New') ifTrue:[^true]].			aSuperclass := aSuperclass superclass.		]. 		^true.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'initalize 5/25/2017 08:15'!isAbstractClass: aClass	| aSuperclass |	 aSuperclass := aClass.		[self isEndOfHierachy:aSuperclass]		whileFalse: [			aSuperclass selectorsDo:[:sel | (self isMethod:sel abstractIn:aClass) ifTrue:[^true]].			aSuperclass := aSuperclass superclass.			].	^false."(aClass allSelectors) do:[:sel | (MyObject isMethod:sel abstractIn:aClass) ifTrue:[^true]].^false."! !!MyObject class methodsFor: 'injection' stamp: 'rj 5/19/2017 18:27'!commentExistOnSecondLine:aString	"the method return a boolean if comment exist on second line of a method (aString)"	|lineNumber hadBeenCommented targetChar |	targetChar:=$".	lineNumber:=1.	(ReadStream on: aString) do: [ :currentChar | 			(lineNumber=2 and:[currentChar=targetChar ]) ifTrue:[ ^(hadBeenCommented:=true) ].	(lineNumber>2) ifTrue:[^false].	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"	^false.! !!MyObject class methodsFor: 'injection' stamp: 'rj 5/19/2017 18:27'!extractArgs: aString	"the method will extract the arguments to a orderedCollection of a method which will be returned."	| parser argsAsOrderedCollection |	parser:=Parser new.	"using the parser to get the aguments names"	argsAsOrderedCollection := parser parseParameterNames: aString.	^argsAsOrderedCollection.! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/24/2017 21:14'!extractReturn:aString	"the method will extract the returned type from aString. if not found Nil will be returned"	| regexObj returnedValue  |	regexObj := '\^([^.]*)\s*' asRegex.	regexObj search: (aString asString).	returnedValue := (regexObj  subexpression:2). 	^returnedValue.	! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/24/2017 19:11'!extractTypes: aString annotatedBy: annotation	"the method will extract the types of ArgTypes from a String"	|regexObj typesInString orderedTypes regexString|	"the ordeder of the types is imprtant so we save it in an orderedCollection"	orderedTypes := OrderedCollection new.	"@New"	"pulling all the types in argTypes via regex, including spaces"		regexString:='"@',annotation,'\:([^\.]+)\."'.	regexObj :=  regexString asRegex.	regexObj search: aString.	typesInString := (regexObj subexpression: 2) asString.	"adding the types to the collection which match with a word"	typesInString regex: '\w+' matchesCollect:[:each | orderedTypes add: each].		^orderedTypes.			! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/24/2017 19:47'!inject:code toMethod: aString	"the method return the method string with the injected code"	| result targetLine pipeExist commentExist blockExist |targetLine :=2.pipeExist :=self char:($|) existOnLine:targetLine in:aString.commentExist :=self char:($") existOnLine:targetLine in:aString.blockExist :=self char:($[) existOnLine:targetLine in:aString.(pipeExist and:[commentExist not] and:[blockExist not]) ifTrue:[targetLine:=targetLine+1]."now we have a good target, and we are need to look for the target line and inject it"result:=self inject:code toMethod:aString inLine:targetLine.^result.! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/23/2017 12:06'!inject:code toMethod: aString inLine: targetLine	"the method return the method string with the injected code"	|lineNumber wasAdded result|lineNumber:=1.wasAdded:=false.result:=''.(ReadStream on: aString) do: [ :currentChar | 	(lineNumber=targetLine and:[wasAdded=false]) ifTrue:[												result:=result,code. 												wasAdded:=true.												     ].	result:=result,currentChar.	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"^result.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:45'!addNewToSubclasses:selector in:aClass|methodCode tagSet|aClass allSubclassesDo:[:sub |	 (sub includesSelector:selector) ifTrue:[ "method exist on sub"										methodCode :=  ((sub sourceMethodAt:selector) asString). "get method code"										tagSet := self getTags:methodCode. 										((tagSet includes:'New') or:[tagSet includes:'Override']) ifFalse:[ "if any subclass does not have @Override or @New we add @New"										methodCode := (MyObject inject:'"@New"' toMethod:methodCode).										sub compile:methodCode] "end of trueBlock"				]."end of outer trueBlock"		]. "end of do block"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 22:31'!compile: text classified: category notifying: requestor	"the following method should:"	"check for errors"	"get the tags"	"change code"	|checkArgumentsEX checkReturnEx  tagSet orderedArgs orderedTypes returnValue returnTypes returnValueCollection argAnnotation returnAnnotation methodResult returnChar returnLine  methodName|		methodName:=self getMethodName:text.		tagSet:=MyObject getTags:text.		self validateBadTags:tagSet."validation of Bad Tags (ERROR 1)"		self validateMethodExistence:methodName WithTags:tagSet. "validate tags in heirarchy (ERROR 2,3)"	self validateInvalidHidingWithinMethod:methodName withTags:tagSet. "ERROR 4"		self validateOverrdingPrivateWithinMethod:methodName withTags:tagSet. "ERROR 5"		self validateOverrdingFinalWithinMethod:methodName withTags:tagSet. "ERROR 6"				"need to check for type errors"	tagSet isEmpty ifTrue:[							super compile: text classified: category notifying: requestor.							self addNewToSubclasses:methodName in:self. "last part in the hw"	]ifFalse:["tag set is not empty we should check and inject current method"							checkArgumentsEX:=''.							checkReturnEx:=''.							argAnnotation :='ArgsTypes'.							returnAnnotation := 'RetType'.							returnValueCollection := OrderedCollection new.							orderedArgs := self extractArgs:text.							orderedTypes:= self extractTypes:text annotatedBy: argAnnotation.							returnTypes:= self extractTypes:text annotatedBy: returnAnnotation.							returnValue := self extractReturn:text.							(returnValue isNil) ifTrue:[returnValue:='self'].																					(tagSet includes:argAnnotation) ifTrue:[checkArgumentsEX:=self validate:orderedArgs withTypes:orderedTypes].							checkArgumentsEX :=checkArgumentsEX,'.'.							"we add the return value to the collection to use the same validation method"							returnValueCollection add:returnValue.								(tagSet includes:returnAnnotation) ifTrue:[checkReturnEx:= self validate:returnValueCollection withTypes:returnTypes].								checkReturnEx := checkReturnEx,'.'.								"inject the return check to the method,as next line after delceration"								 returnChar:=$^.								"we need to find the line to inject the return value"								returnLine := self findChar:returnChar in:text.								methodResult:=text.								(returnLine>0) ifTrue:[									methodResult := (self inject: checkReturnEx toMethod: methodResult inLine:returnLine).								].							methodResult := (self inject: checkArgumentsEX toMethod: methodResult).							(tagSet includes:'Abstract') ifTrue:[methodResult:=self changeToAbstract: text].							(tagSet includes:'Private') ifTrue:[methodResult:=self addPrivateCheck: methodResult].							super compile: methodResult classified: category notifying: requestor.	]."tagSet is not Empty End" ! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 09:57'!getMethodName:methodText	"the method returns the method name of methodText"	| parser methodName|	parser:= Parser new.	methodName :=parser parseSelector:methodText.	^methodName.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/25/2017 08:41'!isEndOfHierachy:aClass	^aClass==nil or:[aClass == (MyObject superclass)].! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:08'!isNewAfterAbstract:selector in:aClass	"Look down the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the subclass chain and try again.	Return nil if no method is found."	| sub  methodCode|	sub := aClass subclasses. "array of all subclasses"	(sub = #() ) ifTrue:[^false].	sub do:[:subClazz | 		(subClazz includesSelector:selector) ifTrue:[			methodCode :=  ((subClazz sourceMethodAt:selector) asString).			((MyObject getTags:methodCode) includes:'New') ifTrue:[^true] ifFalse:[^false].						] ifFalse:[			(self isNewAfterAbstract:selector in: subClazz) ifTrue:[^true]			].		].	^false.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 22:22'!isOverrideNext:selector in:aClass	| sub  methodCode|	sub := aClass subclasses. "array of all subclasses"	(sub = #() ) ifTrue:[^false].	sub do:[:subClazz | 		(subClazz includesSelector:selector) ifTrue:[ |tagSet|			methodCode :=  ((subClazz sourceMethodAt:selector) asString).			tagSet:=MyObject getTags:methodCode.			(tagSet includes:'Override') ifTrue:[^true] ifFalse:[(tagSet includes:'New') ifTrue:[^false]].			] ifFalse:[			(self isOverrideNext:selector in: subClazz) ifTrue:[^true]			].		].	^false.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 20:27'!validate: orderedArgs withTypes: orderedTypes	"the method validates the ordered collection to be with the same kind of type,	 on compile time and runtime. the method will return the runtime check to inject"	|argCheckText  i |	(orderedTypes isNil) ifTrue:[self throwWrongType].	((orderedArgs size>0) and:[ orderedArgs size ~= orderedTypes size ] ) ifTrue:[ self throwWrongType.].	"arguments and the types are on the same size"	"inorder to check their types we will return a block check that will be activated on runtime"	i :=1.	argCheckText := '('.	[i<=orderedArgs size] whileTrue:[ | arg type |	arg := orderedArgs at:i.	type := orderedTypes at:i.	argCheckText:=argCheckText,'(',arg,' isKindOf:',type,') & '.	i:=i+1.	].	argCheckText:=argCheckText,'true)'. "to end concanting right, and to handle it to be default true"	argCheckText:=argCheckText,'ifFalse:[MyObject throwWrongType].'.	^argCheckText.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 09:44'!validateBadTags:tagSet	((tagSet includes: 'Abstract') & (tagSet includes: 'Final'))  ifTrue: [self throwBadTags]. 	((tagSet includes: 'Override') & (((tagSet includes: 'New') | (tagSet includes: 'Private'))))  ifTrue: [self throwBadTags]. "ERROR 1"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:50'!validateInvalidHidingWithinMethod:methodName withTags:tagSet	"ERROR 4"	((self isMethod:methodName abstractIn:(self superclass)) and:[tagSet includes:'New']) ifTrue:[self throwCanNotHideAbstractMethod]. 	"Err 4 Pt2"	((tagSet includes: 'Abstract') and:[(self isNewAfterAbstract:methodName in:self)]) ifTrue:[self throwCanNotHideAbstractMethod]. ! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:57'!validateMethodExistence:methodName WithTags:tagSet	(((self superclass) lookupSelector:methodName) = nil) ifFalse:[((tagSet includes:'New')| (tagSet includes:'Override'))		 ifFalse:[self throwMethodAlreadyExist]]  "ERROR 2"	ifTrue:[((tagSet includes:'New')| (tagSet includes:'Override')) ifTrue:[self throwMethodDoesNotExist]].   "ERROR 3"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:26'!validateOverrdingFinalWithinMethod:methodName withTags:tagSet	"Error 6"	(self isMethod:methodName finalIn:(self superclass)) ifTrue:[(tagSet includes:'Override') ifTrue:[self throwCanNotOverrideFinal]].	"Err 6 Pt2"	(tagSet includes: 'Final') ifTrue:[(self isOverrideNext:methodName in:self) ifTrue:[self throwCanNotOverrideFinal]].! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:24'!validateOverrdingPrivateWithinMethod:methodName withTags:tagSet	"ERROR 5"	(self isMethod:methodName privateIn:(self superclass)) ifTrue:[(tagSet includes:'Override') ifTrue:[self throwCanNotOverridePrivate]].	"Err 5 Pt2"	(tagSet includes: 'Private') ifTrue:[(self isOverrideNext:methodName in:self) ifTrue:[self throwCanNotOverridePrivate]].! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 20:25'!throwAbstractMethodInvoked	AssertionFailure signal:'Abstract method called!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:50'!throwBadTags	"the method thow bad tag tags error"	AssertionFailure signal: 'Bad Tags!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotAccessMethod	AssertionFailure signal: 'Cannot access method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotHideAbstractMethod	AssertionFailure signal: 'Cannot hide Abstract method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotInitAbstract	AssertionFailure signal: 'Cannot instantiate abstract class!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOverrideFinal	AssertionFailure signal:'Cannot override Final method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOverridePrivate	AssertionFailure signal: 'Cannot override Private method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOvverrideFinal	AssertionFailure signal: 'Cannot override Final method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwMethodAlreadyExist	AssertionFailure signal:'Method already exists!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwMethodDoesNotExist	AssertionFailure signal: 'Method does not exist!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwWrongType	AssertionFailure signal: 'Wrong Type!!'.! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!A methodsFor: 'as yet unclassified' stamp: 'initalize 5/25/2017 08:40'!bar	^2! !!A methodsFor: 'as yet unclassified' stamp: 'initalize 5/25/2017 08:40'!foo			(			(	(thisContext client) class	)  includesLocalSelector: (#foo)		)		 ifFalse:[			MyObject throwCanNotAccessMethod.			]...		^1	"@Private"! !A subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #D	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!D subclass: #AB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!AB subclass: #A1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!A1 subclass: #A2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!A2 subclass: #A3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!AB subclass: #B1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!B1 subclass: #B2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!B2 subclass: #B3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #DObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!DObject methodsFor: 'text' stamp: 'initalize 5/24/2017 16:48'!f:a^self.! !DObject subclass: #FObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!FObject methodsFor: 'text' stamp: 'initalize 5/24/2017 16:47'!f:a"@Override"^self.! !!FObject methodsFor: 'text' stamp: 'initalize 5/24/2017 13:56'!g..."@Override"... ^super f.! !MyObject subclass: #Tywin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Tywin methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |((oneChicken isKindOf:SmallInteger) & (twoChicken isKindOf:Integer) & (allChickens isKindOf:SmallInteger) & true)ifFalse:[MyObject throwWrongType]..	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger.".	^ (oneChicken + twoChicken + allChickens).		! !!Tywin methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!h	| sum |.	"@NOT Abstract"	sum := 5.(( (sum even) isKindOf:Boolean) & true)ifFalse:[MyObject throwWrongType]..	^ (sum even).	"@RetType: Boolean."! !Tywin subclass: #Cersei	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Cersei methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |((oneChicken isKindOf:SmallInteger) & (twoChicken isKindOf:Integer) & (allChickens isKindOf:SmallInteger) & true)ifFalse:[MyObject throwWrongType]..	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger.".	^ (oneChicken + twoChicken + allChickens).	! !!Cersei methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!h	| sum |.	"@NOT Abstract"	sum := 5. "@Override"(( (sum even) isKindOf:Boolean) & true)ifFalse:[MyObject throwWrongType]..	^ (sum even).	"@RetType: Boolean."! !Cersei subclass: #Tommen	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Tommen methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |((oneChicken isKindOf:SmallInteger) & (twoChicken isKindOf:Integer) & (allChickens isKindOf:SmallInteger) & true)ifFalse:[MyObject throwWrongType]..	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger.".	^ (oneChicken + twoChicken + allChickens).	! !!Tommen methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 23:19'!h	| sum |.	"@NOT Abstract"	sum := 5. "@Override"(( (sum even) isKindOf:Boolean) & true)ifFalse:[MyObject throwWrongType]..	^ (sum even).	"@RetType: Boolean."! !TestCase subclass: #YarivTestsEX3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!YarivTestsEX3 methodsFor: 'initialize-release' stamp: 'in 5/21/2017 01:07'!setUp	(Smalltalk hasClassNamed: #MyObject) ifTrue: [Smalltalk removeClassNamed: #D].	(Smalltalk hasClassNamed: #D) ifTrue: [Smalltalk removeClassNamed: #AB].	(Smalltalk hasClassNamed: #AB) ifTrue: [Smalltalk removeClassNamed: #A1].	(Smalltalk hasClassNamed: #A1) ifTrue: [Smalltalk removeClassNamed: #A2].	(Smalltalk hasClassNamed: #A2) ifTrue: [Smalltalk removeClassNamed: #A3].	(Smalltalk hasClassNamed: #AB) ifTrue: [Smalltalk removeClassNamed: #B1].	(Smalltalk hasClassNamed: #B1) ifTrue: [Smalltalk removeClassNamed: #B2].	(Smalltalk hasClassNamed: #B2) ifTrue: [Smalltalk removeClassNamed: #B3].		MyObject subclass: #D		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	D subclass: #AB		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	AB subclass: #A1 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	A1 subclass: #A2 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	A2 subclass: #A3 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	AB subclass: #B1		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	B1 subclass: #B2 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	B2 subclass: #B3 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 00:27'!test_10_classCanUnderstand|fInA2 fPrivateInA2 fNewInA3 fAbstractInB1 fOverrideB1 fAbstractA1 fOverrideAbstract|fInA2:='fInA2'.fPrivateInA2:='fPrivateInA2				"@Private"'.fNewInA3:='fPrivateInA2			"@New"'.			fAbstractA1:='fAbstractA1	"@Abstract"'.fOverrideAbstract:='fAbstractA1	"@Abstract"	"@Override"'.	fAbstractInB1:='fAbstractInB1		"@Abstract"'.fOverrideB1:='fAbstractInB1	"@Override"'.(YarivTestsEX3) new removeAllLannisterSelectors.	A2 compile: fInA2.		self assert: (AB classCanUnderstand: #'fInA2' )not. "fInA2 is NOT in AB"	self assert: (A1 classCanUnderstand: #'fInA2' )not."fInA2 is NOT in A1"	self assert: (A2 classCanUnderstand: #'fInA2' ). "fInA2 in A2".	self assert: (A3 classCanUnderstand: #'fInA2' )."fInA2 in A3".		self assert: (B1 classCanUnderstand: #'fInA2' )not."f is NOT in B1"	A2 compile: fPrivateInA2.	self assert: (A2 classCanUnderstand: #'fPrivateInA2' )."fPrivateInA2 in A2".	self assert: (A3 classCanUnderstand: #'fPrivateInA2' )not."fPrivateInA2 in A3".	A3 compile: fNewInA3.		self assert: (A3 classCanUnderstand: #'fPrivateInA2' )."fPrivateInA2 in A3".	B1 compile:fAbstractInB1.	self assert: (B1 classCanUnderstand: #'fAbstractInB1' )not."fAbstractInB1 isAbstract".	self assert: (B2 classCanUnderstand: #'fAbstractInB1' )not."fAbstractInB1 isAbstract".	self assert: (B3 classCanUnderstand: #'fAbstractInB1' )not."fAbstractInB1 isAbstract".		self assert: (A1 classCanUnderstand: #'fAbstractInB1' )not."fAbstractInB1 not defined".		B2 compile:	fOverrideB1.	self assert: (B2 classCanUnderstand: #'fAbstractInB1' )."Not Abstract".		self assert: (B3 classCanUnderstand: #'fAbstractInB1' )."Not Abstract".			self assert: (B1 classCanUnderstand: #'fAbstractInB1' )not." Abstract".								self assert: (A1 classCanUnderstand: #'fAbstractInB1' )not." not defined".				A1 compile: fAbstractA1.	self assert: (A1 classCanUnderstand: #'fAbstractA1' )not."Abstract".		self assert: (A2 classCanUnderstand: #'fAbstractA1' )not."Abstract".			A2 compile:fOverrideAbstract.		self assert: (A1 classCanUnderstand: #'fAbstractA1' )not."Abstract".			self assert: (A2 classCanUnderstand: #'fAbstractA1' )not."Abstract".			self assert: (A3 classCanUnderstand: #'fAbstractA1' )not."Abstract".					! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 01:19'!test_11_Error2|fInA1 fInA2withoutOverOrNew fInA2withNew fInA2withOverride isException|fInA1:='fInA1'.fInA2withoutOverOrNew:='fInA1'.fInA2withNew:='fInA1 	"@New"'.	fInA2withOverride:='fInA1 	"@Override"'.(YarivTestsEX3) new removeAllLannisterSelectors.	A1 compile: fInA1.	isException := false.	[(A2 compile:fInA2withoutOverOrNew)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Method already exists!!')]. "already in A1 "	self assert: isException.		isException := false.	[(B1 compile:fInA2withoutOverOrNew)] on: AssertionFailure do:[ :e | 	isException := true	].	self assert: isException not. 			isException := false.	[(A2 compile:fInA2withNew)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.				isException := false.	[(A2 compile:fInA2withOverride)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.		isException := false.	[(A2 compile:fInA1)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Method already exists!!')]. "already in A1 "	self assert: isException.		! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 03:10'!test_12_Error4|fSimple fSimpleNew fSimpleOverride isException fInB2 fInD fNewDInA2 fAbstractInAB|fSimple:='fSimple	"@Abstract"'.fSimpleOverride:= 'fSimple"@Override"'.fSimpleNew:='fSimple"@New"'.	fInB2:='fInB2'.fInD:='fInD'.fNewDInA2:='fInD"@New"'.fAbstractInAB:='fInD"@Override""@Abstract"'.	(YarivTestsEX3) new removeAllLannisterSelectors.AB compile: fSimple.	isException := false.	[(B2 compile: fSimpleNew)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')]. "fSimple is Abstract"	self assert: isException.		isException := false.	[(B1 compile: fSimpleOverride)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.		isException := false.	[(B2 compile: fSimpleNew)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.	"Now it's ok"	D compile: fInD.	isException := false.	[(A2 compile:fNewDInA2)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.				isException := false.	[(AB compile:fAbstractInAB)] on: AssertionFailure do:[ :e | 	self assert:(e messageText = 'Cannot hide Abstract method!!').		isException := true].	self assert: isException.	 	A2 removeSelector: (fInD asSymbol).		isException := false.	[(B2 compile:fNewDInA2)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not.			isException := false.	[(AB compile:fAbstractInAB)] on: AssertionFailure do:[ :e | 	self assert:(e messageText = 'Cannot hide Abstract method!!').		isException := true].	self assert: isException.	 					isException := false.	[(A2 compile:fAbstractInAB)] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not. "if you failed in this test you probably using the 'lookupSelector' in your function 								 which gives you the method defined in class D, 	take a look and change it!!!!"		! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 18:40'!test_1GetTags|fNoTags fAllTags fTagsWithSpacesTabsNewLines fCombineTags fTagsMoreCases TempTags|fNoTags:= 'f1'.fAllTags:='f2"@Private""@Final""@Abstract""@New""@Override""@ArgsTypes: String.""@RetType: String."'.fTagsWithSpacesTabsNewLines:='fTagsWithSpacesOrTabs" @Final""@Final "" @Final ""	@Final""@Final	""@Final		""@ Final"" @ Final""@Fin al""@Final""@Final""@ArgsTypes :""@ArgsTypes	:""@RetTypes :""@RetTypes	:""@RetTypes:"'.fCombineTags:= 'fCombineTags"@Final @Private""@ArgsTypes @Private, @Final:.""@ArgsTypes @Private, @Final:""@Final@Private""@Final@Private""@RetType @Final:.""@@Final"'.fTagsMoreCases:= 'fTagsMoreCases "@Override""|x|" "@Private"x:= ''@Final''."x:= @Final"."@New" "@ArgsTypes:SmallInteger.""@RetType:SmallInteger."'.(YarivTestsEX3) new removeAllLannisterSelectors.self assert: ((AB getTags: fNoTags) size = 0). "No tags"self assert: ((AB getTags: fAllTags) size = 7). "All tags"self assert: ((AB getTags: fTagsWithSpacesTabsNewLines) size = 0). "fTagsWithSpacesTabsNewLines"self assert: ((AB getTags: fCombineTags) size = 0). "fCombineTags"TempTags := Set new.  TempTags add: 'Override'.TempTags add: 'New'.TempTags add: 'Private'.TempTags add:'ArgsTypes'.TempTags add:'RetType'.self assert:((AB getTags: fTagsMoreCases) =  TempTags).  "Tags: Override, New, Private, ArgsTypes, RetType "! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 14:26'!test_2_CheckArgsTypes|fSimple  fIsKindOf  fOneLine fwithVar fwithVar2 fwithoutVar x isException|fSimple:='fSimple:x"@ArgsTypes: SmallInteger."'.fIsKindOf:='fIsKindOf:x"@ArgsTypes: LargeNegativeInteger."'.fOneLine:='fOneLine:x^x."@ArgsTypes: SmallInteger."'.fwithVar:='fwithVar:x |y z|"@ArgsTypes: SmallInteger."'.fwithVar2:='fwithVar2:x |y z|^x."@ArgsTypes: SmallInteger."'.fwithoutVar:='fwithoutVar:x"|y z|"^x."@ArgsTypes: SmallInteger."'.(YarivTestsEX3) new removeAllLannisterSelectors.	AB compile: fSimple.		x:=4.	isException := false.	[(AB new) fSimple: (x )] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.	AB compile: fIsKindOf.	x:=-9999999999999999999999.		isException := false.	[(AB new) fIsKindOf: x] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.	"x isKindOf LargeNegativeInteger "	x:=9999999999999999999999.		isException := false.	[(AB new) fIsKindOf: x] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException. "x is NOT KindOf LargeNegativeInteger "		AB compile: fOneLine.	x:=4.	isException := false.	[(AB new) fOneLine: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.			AB compile: fwithVar.	x:=4.	isException := false.	[(AB new) fwithVar: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.		AB compile: fwithVar2.	x:=4.	isException := false.	[(AB new) fwithVar2: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.		AB compile: fwithoutVar.	x:=4.	isException := false.	[(AB new) fwithoutVar: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 14:26'!test_3_CheckReturnType|fSimpleRt fwithValRt fvalChange fvalChange2 fwithStatement fwithStatement2 isException x|fSimpleRt:='fSimpleRt:x"@RetType: SmallInteger."^x.'.fwithValRt:='fwithValRt:x|y|y:=4."@RetType: SmallInteger."^y.'.fvalChange:='fvalChange:x|y|y:=''a''."@RetType: SmallInteger."y:=4.^y.'.fvalChange2:='fvalChange2:x|y|y:=4."@RetType: SmallInteger."y:=''a''.^y.'.fwithStatement:='fwithStatement:x|y|y:=''a''."@RetType: ByteSymbol."^(y asSymbol).'.fwithStatement2:='fwithStatement2:x|y z|y:=999999999.z:=999999999."@RetType: LargePositiveInteger."^z+y.'.(YarivTestsEX3) new removeAllLannisterSelectors.	AB compile: fSimpleRt.	x:=4.	isException := false.	[(AB new) fSimpleRt: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.	AB compile: fwithValRt.	x:=4.	isException := false.	[(AB new) fwithValRt: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.	AB compile: fvalChange.	x:=4.	isException := false.	[(AB new) fvalChange: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.		AB compile: fvalChange2.	x:=4.	isException := false.	[(AB new) fvalChange2: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException.AB compile: fwithStatement.	x:=4.	isException := false.	[(AB new) fwithStatement: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.AB compile: fwithStatement2.	x:=4.	isException := false.	[(AB new) fwithStatement2: x ] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.	! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'in 5/21/2017 02:37'!test_4_isAbstractMethod|fAbstractInAB fAbstractInABnotInB2 |fAbstractInAB:= 'fAbstractInAB					"@Abstract"					'.					fAbstractInABnotInB2:='fAbstractInAB					"@Override"					'.							(YarivTestsEX3) new removeAllLannisterSelectors.	AB compile: fAbstractInAB.	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: AB). "Abstract in AB"	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: A2). "Abstract in A2"	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: B2). "Abstract in B2"	B2 compile: fAbstractInABnotInB2.	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: AB). "Abstract in AB"	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: A2). "Abstract in A2"	self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: B2)not. " NOT Abstract in B2"			A3 compile: fAbstractInABnotInB2.		self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: A2). "Abstract in A2"		self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: B1). "Abstract in B1"		self assert: (MyObject isMethod: #'fAbstractInAB' abstractIn: A3)not. "NOT Abstract in A3"						! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 19:24'!test_5_isAbstractClass|fAbstract fNotAbstract f2AbsractIn|fAbstract:= 'f			"@Abstract"			'.					fNotAbstract:='f					"@Override"					'.f2AbsractIn:= 'f2AbsractIn				"@Abstract"					'.														(YarivTestsEX3) new removeAllLannisterSelectors.	AB compile: fAbstract.	self assert: (MyObject isAbstractClass: AB). "AB is Abstract"	self assert: (MyObject isAbstractClass: A2). "A2 is Abstract"	self assert: (MyObject isAbstractClass: B2). "B2 is Abstract"	B2 compile: fNotAbstract.	self assert: (MyObject isAbstractClass: AB). "AB is Abstract"	self assert: (MyObject isAbstractClass: B2)not. "B2 is NOT Abstract"	self assert: (MyObject isAbstractClass: A2). "A2 Abstract"		B2 compile: f2AbsractIn.		self assert: (MyObject isAbstractClass: B2). "B2 Abstract"	self assert: (MyObject isAbstractClass: B3). "B3 Abstract"		A3 compile: fNotAbstract.	self assert: (MyObject isAbstractClass: A3)not. "A3 is NOT Abstract"	self assert: (MyObject isAbstractClass: A2). "A2 Abstract"		! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 19:47'!test_6_Error7|fSimple fSimple2  isException|fSimple:='f "@Abstract".'.fSimple2:='f"@Override".'.(YarivTestsEX3) new removeAllLannisterSelectors.	isException := false.	AB compile: fSimple.	[(AB new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "AB is Abstract"	self assert: isException.		isException := false.	[(A1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "A1 is Abstract"	self assert: isException.			isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 is Abstract"	self assert: isException.	    B2 compile:fSimple2.		isException := false.	[(AB new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "AB is Abstract"	self assert: isException.		isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 is Abstract"	self assert: isException.		isException := false.	[(B2 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. 	self assert: isException not. "B2 is NOT Abstract"						isException := false.	[(B3 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. 	self assert: isException not. "B3 is NOT Abstract"		isException := false.	[(A2 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "A2 Abstract"	self assert: isException. 	! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 20:51'!test_7_Error9|fSimple fSimple2 fwithReturnValue isException fwithReturnValueNotAbstract  fwithReturnValue2  fwithArgsAndReturnValue  b1 x |fSimple:='f "@Abstract".'.fSimple2:='f"@Override".'.fwithReturnValue:='fwithReturnValue^1."@Abstract"'.fwithReturnValue2:='fwithReturnValue2|y|"@Abstract"^1.'.fwithArgsAndReturnValue:='fwithArgsAndReturnValue:x|y|"@Abstract"^1.'.fwithReturnValueNotAbstract:='fwithReturnValue"@Override"^2'.(YarivTestsEX3) new removeAllLannisterSelectors.	isException := false.	AB compile: fSimple.	[(AB new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "AB is Abstract"	self assert: isException.		isException := false.	[(A1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "A1 is Abstract"	self assert: isException.			isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 is Abstract"	self assert: isException.	    B2 compile:fSimple2.		isException := false.	[(AB new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "AB is Abstract"	self assert: isException.		isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 is Abstract"	self assert: isException.		isException := false.	[(B2 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. 	self assert: isException not. "B2 is NOT Abstract"						isException := false.	[(B3 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. 	self assert: isException not. "B3 is NOT Abstract"		isException := false.	[(A2 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "A2 Abstract"	self assert: isException. 	B1 compile: fSimple2.	isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 Not Abstract"	self assert: isException not. 						isException := false.	[	b1:= B1 new.	x:=0.	AB compile:fwithReturnValue.	x:= b1 fwithReturnValue. 	] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Abstract method called!!'). "fwithReturnValue is Abstract in AB"	self assert:(x=0)."x should be 0"	]. 	self assert: isException. 				isException := false.	[x:=0.	AB compile:fwithReturnValue2.	x:= b1 fwithReturnValue2. 	] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Abstract method called!!'). "fwithReturnValue is Abstract in AB"	self assert:(x=0)."x should be 0"	]. 	self assert: isException. 				isException := false.	[x:=0.	AB compile: fwithArgsAndReturnValue.	x:= b1 fwithArgsAndReturnValue:5. 	] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Abstract method called!!'). "fwithReturnValue is Abstract in AB"	self assert:(x=0)."x should be 0"	]. 	self assert: isException. 			 	isException := false.	[(B1 new)] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "B1 Abstract"	self assert: isException. 						! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 21:01'!test_8_Error1VsError7|fThrowError1 isException|fThrowError1:='fThrowError1"@Final""@Abstract"'.(YarivTestsEX3) new removeAllLannisterSelectors.	isException := false.	[AB compile: fThrowError1] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Final and Abstract"	self assert: isException.		isException := false.	[(AB new) ] on: AssertionFailure do:[ :e | 	isException := true].	self assert: isException not. "should not throw exception"! !!YarivTestsEX3 methodsFor: 'testing' stamp: 'i 5/20/2017 22:17'!test_9_Error9VsError8|fAbstractAndPrivate fPrivate b1 b3 isException fNew|fAbstractAndPrivate:='fAbstractAndPrivate"@Abstract""@Private"'.fPrivate:= 'fPrivate"@Private"'.fNew:= 'fPrivate"@New"'.(YarivTestsEX3) new removeAllLannisterSelectors. isException := false. [	b3:=B3 new.	B2 compile: fAbstractAndPrivate.	b3 fAbstractAndPrivate. 	] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Cannot access method!!'). " Error8 should come before Error9"	]. 	self assert: isException. 			 		 isException := false.	[	AB compile: fPrivate. 	B1 compile: fNew.	b1:=B1 new. 	b1 fPrivate.	] on: AssertionFailure do:[ :e | 	isException := true ]. 	self assert: isException not.  	 				 isException := false.	[	(A1 new) fPrivate.	] on: AssertionFailure do:[ :e | 	self assert:(e messageText = 'Cannot access method!!'). " Error8"	isException := true ]. 	self assert: isException .  	 			! !!YarivTestsEX3 methodsFor: 'private' stamp: 'in 5/21/2017 01:07'!removeAllLannisterSelectors	"Removes all the selectors if all the classes for the test"		YarivTestsEX3 new removeAllSelectorsOfClass: D.	YarivTestsEX3 new removeAllSelectorsOfClass: AB.	YarivTestsEX3 new removeAllSelectorsOfClass: A1.	YarivTestsEX3 new removeAllSelectorsOfClass: A2.	YarivTestsEX3 new removeAllSelectorsOfClass: A3.	YarivTestsEX3 new removeAllSelectorsOfClass: B1.	YarivTestsEX3 new removeAllSelectorsOfClass: B2.	YarivTestsEX3 new removeAllSelectorsOfClass: B3.! !!YarivTestsEX3 methodsFor: 'private' stamp: 'i 5/20/2017 18:36'!removeAllSelectorsOfClass: aClass	"Given a class, this methods removes all the selectors in class' method dictionary"	(aClass selectors) do: [:s | aClass removeSelector: s.].		! !