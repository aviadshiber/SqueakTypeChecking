TestCase subclass: #ExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ExampleTest methodsFor: 'as yet unclassified' stamp: 'NM 11/30/2015 17:15'!setUp	(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].	(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].	MyObject subclass: #A		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.
	A subclass: #B 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.! !!ExampleTest methodsFor: 'as yet unclassified' stamp: 'NM 11/30/2015 17:22'!testExample|temp|	A compile: 'foo
	^1	"@Private"'.	A compile: 'bar	^2'.	self assert: ((B classCanUnderstand: #foo) = false).	self assert: ((B new instRespondsTo: #foo) = false).	self assert: ((B classCanUnderstand: #bar) = true).	self assert: ((B new instRespondsTo: #bar) = true).	temp := false.	[		B compile: 'bar		^3'	] on: AssertionFailure do:	[:e|		temp := true.		self assert:(e messageText = 'Method already exists!!').	].	self assert: (temp = true).	temp := false.	[		B compile: 'moo		^4 "@Abstract" "@Final"'	] on: AssertionFailure do:	[:e|		temp := true.		self assert:(e messageText = 'Bad Tags!!').	].	self assert: (temp = true).! !TestCase subclass: #GuyOmerTestsEX3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!GuyOmerTestsEX3 methodsFor: 'initialize-release' stamp: 'guy 5/8/2017 15:36'!setUp	(Smalltalk hasClassNamed: #MyObject) ifTrue: [Smalltalk removeClassNamed: #Tywin].	(Smalltalk hasClassNamed: #Tywin) ifTrue: [Smalltalk removeClassNamed: #Cersei].	(Smalltalk hasClassNamed: #Cersei) ifTrue: [Smalltalk removeClassNamed: #Tommen].	MyObject subclass: #Tywin		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	Tywin subclass: #Cersei 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.	Cersei subclass: #Tommen 		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'OOP3'.! !!GuyOmerTestsEX3 methodsFor: 'aux - methods' stamp: 'guy 5/10/2017 07:46'!removeAllLannisterSelectors	"Removes all the selectors if all the classes for the test"		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tywin.	GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tommen.! !!GuyOmerTestsEX3 methodsFor: 'aux - methods' stamp: 'guy 5/10/2017 07:43'!removeAllSelectorsOfClass: aClass	"Given a class, this methods removes all the selectors in class' method dictionary"	(aClass selectors) do: [:s | aClass removeSelector: s].! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:09'!test1GetTags	| fTywin fCersei hCersei hTommen fCerseiTags hCerseiTags hTommenTags gTywin gTywinTags iTommen jTommen kTommen |	fTywin := 'f	"@Private is not public"	Transcript show: ''f''.'.	fCersei := 'f	"@Override"	Transcript show: ''f''.'.	hCersei := 'h	Transcript show: 3. "@N ew"	^ true.	"@RetType: Boolean"'.	hTommen := 'h	Transcript show: 3. "@New"	^ true.	"@RetType: Boolean"'.	gTywin :='g: x and: y	"@Private" Transcript show: x; show: y.	"@ArgsTypes: SmallInteger, SmallInteger."'.	iTommen := 'i	Transcript show: ''i''. "@Fi	nal"'.	jTommen := 'j	"I am not a @Private method"'.	kTommen := 'k	Transcript show: 5. "@new" "(lowercase)"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: fTywin.	self assert: ((Tywin getTags: fTywin) size = 0). "No tags"	fCerseiTags := Set new.  fCerseiTags add: 'Override'.	Cersei compile: fCersei.	self assert:((Cersei getTags: fCersei) =  fCerseiTags). "Tags: Override"	hCerseiTags := Set new.  hCerseiTags add: 'RetType'.	Cersei compile: hCersei.	self assert:((Cersei getTags: hCersei) =  hCerseiTags).  "Tags: RetType"	hTommenTags := Set new.  hTommenTags add: 'New'. hTommenTags add: 'RetType'.	Tommen compile: hTommen.	self assert:((Tommen getTags: hTommen) =  hTommenTags).  "Tags: RetType , New"	gTywinTags := Set new.  gTywinTags add: 'ArgsTypes'. gTywinTags add: 'Private'.	Tywin compile: gTywin.	self assert:((Tywin getTags: gTywin) =  gTywinTags).  "Tags: Private , ArgsTypes"	Tommen compile: iTommen.	self assert:((Tommen getTags: iTommen) size = 0).  "No Tags"	Tommen compile: jTommen.	self assert:((Tommen getTags: jTommen) size =  0).  "No Tags"	Tommen compile: kTommen.	self assert:((Tommen getTags: kTommen) size =  0).  "No Tags"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 22:18'!test2CheckArgsTypes	| gTywin isException funTommen |	gTywin :='g: x and: y			 	 	 	| privy |	"@NOT Private" ^(x*y). "@NOTRetType: Number"	"@ArgsTypes: SmallInteger, SmallInteger."'.		funTommen :='fun: aCat with: aNumber 	"@Final" 	"@ArgsTypes: ByteString, Integer."	"@NOTRetType: String" ^''Ser Pounce'''.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: gTywin.	isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.			isException := false.	[(Tywin new) g: 7 and: 'hells'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.		isException := false.	[(Tywin new) g: 'Winter' and: 'is coming'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: funTommen.		isException := false.	[(Tommen new) fun: 'cat of the canals' with: 7] on: AssertionFailure do:[ :e | 	isException := true.].	self assert: isException not.		isException := false.	[(Tommen new) fun: 'cat of the canals' with: 'Not a number thou'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.		isException := false.	[(Tommen new) fun: 'A' with: 'Still not a number'] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:53'!test3CheckRetType	| gTywin isException funTommen omgTywin |	gTywin :='g: x and: y	| privy |	"@NOPrivate" ^(x*y). "@RetType: Number."	"@ArgsTypes: SmallInteger, SmallInteger."'.		omgTywin :='g: x and: y	| privy |	"@NOPrivate" ^(x*y). "@RetType: String."	"@ArgsTypes: SmallInteger, SmallInteger."'.		funTommen :='fun: aCat with: aNumber 	"@Final" 		"@ArgsTypes: ByteString, Integer."	(aNumber even) "@RetType: String." ifTrue:[^''Ser Pounce'']'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: gTywin.		isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | "Should not throw exception"	isException := true.].	self assert: isException not.		Tywin compile: omgTywin.	isException := false.	[(Tywin new) g: 19 and: 84] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Wrong Type!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: funTommen.		isException := false.	[(Tommen new) fun: 'cat of the canals' with: 7] on: AssertionFailure do:[ :e | "Should not throw exception"	isException := true.].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:54'!test4IsMethodAbstractIn	| hMethodAbstract hMethodNotAbstractOverride hMethodAbstractOverride hMethodNotAbstract |	hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractOverride := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean.""@Override"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: hMethodAbstract.	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Tywin"	self assert: (MyObject isMethod: #'h' abstractIn: Tommen). "Abstract in Tywin"	Cersei compile: hMethodNotAbstractOverride.	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	self assert: ((MyObject isMethod: #'h' abstractIn: Cersei) not). "Not Abstract in Cersei"	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Cersei"	Tommen compile: hMethodNotAbstractOverride.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen"	self assert: ((MyObject isMethod: #'h' abstractIn: Cersei) not). "Not Abstract in Cersei"	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	Cersei compile: hMethodAbstractOverride.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen - Tommen overrides Cersei's method"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Cersei"	self assert: (MyObject isMethod: #'h' abstractIn: Tywin). "Abstract in Tywin"	Tywin compile: hMethodNotAbstract.	self assert: ((MyObject isMethod: #'h' abstractIn: Tommen) not). "Not Abstract in Tommen - Tommen overrides Cersei's method"	self assert: (MyObject isMethod: #'h' abstractIn: Cersei). "Abstract in Cersei"	self assert: ((MyObject isMethod: #'h' abstractIn: Tywin) not). "Not Abstract in Tywin"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:55'!test5IsAbstractClass	| hMethodAbstract hMethodNotAbstractOverride hMethodAbstractOverride hMethodNotAbstract chickenMethodNotAbstract chickenMethodNotAbstractOverride |	chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractOverride := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean.""@Override"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: hMethodAbstract.	Tywin compile: chickenMethodNotAbstract.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Tommen). "Abstract because Tywin has an abstract method"	Cersei compile: hMethodNotAbstractOverride.	Cersei compile: chickenMethodNotAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	Tommen compile: hMethodNotAbstractOverride.	Tommen compile: chickenMethodNotAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden the Abstract methods of Tywin"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Cersei compile: hMethodAbstractOverride.	self assert: (MyObject isAbstractClass: Tywin). "Abstract because Tywin has an abstract method"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Cersei has an abstract method"	self assert: ((MyObject isAbstractClass: Tommen) not). "Abstract because Cersei has an abstract method"	Tywin compile: hMethodNotAbstract.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has not abstract methods"	self assert: (MyObject isAbstractClass: Cersei). "Abstract because Cersei has an abstract method"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Cersei compile: hMethodNotAbstractOverride.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has not abstract methods"	self assert: ((MyObject isAbstractClass: Cersei) not). "NOT Abstract because Cersei has overriden with 'Abstract' methods"	self assert: ((MyObject isAbstractClass: Tommen) not). "NOT Abstract because Tommen has overriden the Abstract methods of Tywin"	Tommen compile: hMethodAbstractOverride.	self assert: ((MyObject isAbstractClass: Tywin) not). "Not Abstract because Tywin has no abstract methods"	self assert: ((MyObject isAbstractClass: Cersei) not). "Abstract because Cersei has an abstract method"	self assert: (MyObject isAbstractClass: Tommen). "Abstract because Tommen has an abstract method"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:11'!test6CheckError1	| isException abadiTommen oreoCersei lotusTywin |		abadiTommen := 'abadi	Transcript show: ''abadi is love''. "@Final"			"@Abstract"'.		oreoCersei := 'oreo	"@Override"	Transcript show: ''f''.	Transcript show: 3. "@New"		^ true.	"@RetType: Boolean"'.	lotusTywin := 'lutus	"@Override"	"@Private"	"@Private is not public"	Transcript show: ''f''.'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tommen compile: abadiTommen] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Final + Abstract - DAS IST NICHT GUT"	self assert: isException.		isException := false.	[Cersei compile: oreoCersei] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Override + New - DAS IST NICHT GUT"	self assert: isException.		isException := false.	[Tywin compile: lotusTywin] on: AssertionFailure do:[ :e | 	isException := true.	self assert:(e messageText = 'Bad Tags!!')]. "Override + Private - DAS IST NICHT GUT"	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:55'!test7CheckError9	| abadiMethodNotAbstract isException abadiMethodAbstract aTywin |	abadiMethodAbstract := 'abadi: please	| sum |	"@Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.		abadiMethodNotAbstract := 'abadi: please with: extraPlease	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[aTywin := Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.		Tywin compile: abadiMethodAbstract.		isException := false.	[aTywin abadi: 1984] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Abstract method called!!')]. "This method is 'Abstract' - exception9 should be thrown"	self assert: isException.		Tywin compile: abadiMethodNotAbstract.		isException := false.	[aTywin abadi: 'drink' with: 'things'] on: AssertionFailure do:[ :e | "This method is NOT 'Abstract' - exception9 should NOT be thrown"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:55'!test8CheckError7	| abadiMethodNotAbstract isException abadiMethodAbstract aTywin abadiWithMethodNotAbstract |	abadiMethodAbstract := 'abadi: please	| sum |	"@Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.		abadiMethodNotAbstract := 'abadi: please	| sum |	"@NOT Abstract"	sum := 5.	^ (please isKIndOf: Cersei).	"@RetType: Boolean."'.	abadiWithMethodNotAbstract := 'abadi: please with: extraPlease	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[aTywin := Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.		Tywin compile: abadiMethodAbstract.		isException := false.	[(Tywin new) abadi: 1984] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "Tywin class is 'Abstract' - exception7 should be thrown"	self assert: isException.		Tywin compile: abadiWithMethodNotAbstract.		isException := false.	[(Tywin new) abadi: 1984 with: 'chicken'] on: AssertionFailure do:[ :e |	isException := true.	self assert:(e messageText = 'Cannot instantiate abstract class!!')]. "Tywin class is still 'Abstract' - exception7 should be thrown"	self assert: isException.	Tywin compile: abadiMethodNotAbstract. "Now Tywin class is NOT 'Abstract' "		isException := false.	[Tywin new] on: AssertionFailure do:[ :e | "The method is not 'Abstract' - should should throw exception 7"	isException := true]. 	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:12'!test9CheckError8	| chickenMethodPrivate methodSymbol isException chickenMethodNotPrivate hMethodNotPrivate hMethodNotPrivateNew chickenMethodPrivateNew |		hMethodNotPrivate := 'h: x	"@NOT Private"	"I''m a private method"	^(self checkChicken: 1 nevermind: 2 knowwhat: 3) "@Calls checkChicken method"   '.		hMethodNotPrivateNew := 'h: x	"@NOT Private" "@New"	"I''m a private method andalso a new one"	^(self checkChicken: 1 nevermind: 2 knowwhat: 3) "@Calls checkChicken method"   '.		chickenMethodNotPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Private at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.	chickenMethodPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Private" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@NOT New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	methodSymbol :=#'checkChicken:nevermind:knowwhat:'.	Tywin compile: chickenMethodNotPrivate.	Tywin compile: hMethodNotPrivate.	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodPrivate. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.		"------------------------------------------------------------------------------------------------------------------"	Cersei compile: chickenMethodPrivateNew. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot access method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: chickenMethodPrivateNew. "now this method is private and not visible"	isException := false.	[(Tywin new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Cersei new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[(Tommen new) h: 7] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:13'!test_10classCanUnderstand	| chickenMethodNotAbstract chickenMethodNotAbstractOverride chickenMethodAbstract methodSymbol chickenMethodAbstractOverride chickenMethodNotAbstractPrivate chickenMethodNotAbstractPrivateNew chickenMethodNotAbstractNotPrivateNew chickenMethodAbstractNew |	chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodAbstractNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.		chickenMethodNotAbstractNotPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@NOT Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	methodSymbol :=#'checkChicken:nevermind:knowwhat:'.		"checkChicken does not exist"	Tywin compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).		Tywin compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Cersei compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).		Cersei compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tommen compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol).		Tommen compile: chickenMethodAbstract.	"checkChicken is 'Abstract' "	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol) not.		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tywin compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol) not. "Because 'Private'"	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because 'Private'"	Tywin removeSelector: methodSymbol.	Cersei compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because 'Private'"	Cersei removeSelector: methodSymbol.	Tommen compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin classCanUnderstand: methodSymbol) not.	self assert: (Cersei classCanUnderstand: methodSymbol) not.	self assert: (Tommen classCanUnderstand: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Tywin compile: chickenMethodNotAbstractPrivate.	Cersei compile: chickenMethodNotAbstractNotPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol). "Tommen understands because Cersei has 'New' tag"	Cersei compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol) not. "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	Tommen compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol).	self assert: (Tommen classCanUnderstand: methodSymbol).	Tywin compile: chickenMethodNotAbstract.	self assert: (Tywin classCanUnderstand: methodSymbol).	self assert: (Cersei classCanUnderstand: methodSymbol). 	self assert: (Tommen classCanUnderstand: methodSymbol). "Because Cersei has this method as 'Private' (the 'New' does not affect here) "		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Tywin.	Tommen compile: chickenMethodAbstractNew.	self assert: ((Tywin classCanUnderstand: methodSymbol) not).	self assert: (Cersei classCanUnderstand: methodSymbol). 	self assert: ((Tommen classCanUnderstand: methodSymbol) not). "Because Cersei has this method as 'Private' (the 'New' does not affect here) and Tywin does not have this method at all"	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:14'!test_11InstRespondsTo	| chickenMethodNotAbstract chickenMethodNotAbstractOverride chickenMethodAbstract methodSymbol chickenMethodAbstractOverride chickenMethodNotAbstractPrivate chickenMethodNotAbstractPrivateNew chickenMethodNotAbstractNotPrivateNew chickenMethodAbstractNew |	chickenMethodNotAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.	chickenMethodAbstract := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).		'.		chickenMethodAbstractNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Abstract" "@New"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens)'.		chickenMethodNotAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@NOT Abstract at all pinky swear"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.	chickenMethodAbstractOverride := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	| abadiIsLoveAbadiIsLife |	"@Override"          				   "@Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger."	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivate := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens).	'.		chickenMethodNotAbstractPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.		chickenMethodNotAbstractNotPrivateNew := 'checkChicken: oneChicken nevermind: twoChicken knowwhat: allChickens	"@NOT Override"          				   "@NOT Abstract"	"@ArgsTypes: SmallInteger, Integer, SmallInteger." "@NOT Private"	^ (oneChicken + twoChicken + allChickens) "@New" '.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	methodSymbol :=#'checkChicken:nevermind:knowwhat:'.	"checkChicken does not exist"	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol) not.		Tywin compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.		Cersei compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tommen compile: chickenMethodNotAbstract.	"checkChicken is not 'Abstract' "	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol) not. "Because 'Private'"	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because 'Private'"	Tywin removeSelector: methodSymbol.	Cersei compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because 'Private'"	Cersei removeSelector: methodSymbol.	Tommen compile: chickenMethodNotAbstractPrivate.	self assert: (Tywin new instRespondsTo: methodSymbol) not.	self assert: (Cersei new instRespondsTo: methodSymbol) not.	self assert: (Tommen new instRespondsTo: methodSymbol).		Tywin removeSelector: methodSymbol.	Cersei removeSelector: methodSymbol.	Tommen removeSelector: methodSymbol.	"------------------------------------------------------------------------------------------------------------------"	Tywin compile: chickenMethodNotAbstractPrivate.	Cersei compile: chickenMethodNotAbstractNotPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol). "Tommen understands because Cersei has 'New' tag"	Cersei compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol) not. "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	Tommen compile: chickenMethodNotAbstractPrivateNew.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol).	self assert: (Tommen new instRespondsTo: methodSymbol).	Tywin compile: chickenMethodNotAbstract.	self assert: (Tywin new instRespondsTo: methodSymbol).	self assert: (Cersei new instRespondsTo: methodSymbol). 	self assert: (Tommen new instRespondsTo: methodSymbol). "Because Cersei has this method as 'Private' (the 'New' does not affect here) "	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:56'!test_12CheckError2	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew |		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method already exists!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method already exists!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstract.] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:57'!test_13CheckError3	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew |		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		Tywin removeSelector: #'h'.	Cersei removeSelector: #'h'.	Tommen removeSelector: #'h'.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Method does not exist!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:57'!test_14CheckError4	| hMethodNotAbstractOverride hMethodNotAbstract  isException hMethodNotAbstractNew hMethodAbstract hMethodAbstractNew |		hMethodAbstract := 'h	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodAbstractNew := 'h	| sum |	"@Abstract"	sum := 5.	"@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractOverride := 'h	| sum |	"@NOT Abstract"	sum := 5. "@Override"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstractNew := 'h	| sum |	"@NOT Abstract"	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotAbstract := 'h	| sum |	"@NOT Abstract"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"4.1-------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - 'New' works on superclasses"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Cersei has no implementation (Abstract)"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception - no 'New' "	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception - Cersei has an implementation"	Transcript show: e;cr.	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception - Tywin has NOT Abstract "	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Cersei has no implementation at all"	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.	"4.2-------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodAbstract] on: AssertionFailure do:[ :e | "Should throw exception - Tommen uses 'New' so Tywin can not use 'Abstract' "	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodAbstractNew] on: AssertionFailure do:[ :e | "Should throw exception - Tommen uses 'New' so Cersei can not use 'Abstract' "	isException := true.	self assert:(e messageText = 'Cannot hide Abstract method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNotAbstractNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodNotAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception - Cersei has actual implementation"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:57'!test_15CheckError5	|  hMethodNew hMethodNotPrivate hMethodNotPrivateNew hMethodOverride hMethodPrivate hMethodPrivateNew isException |		hMethodPrivate := 'h	| sum |	"@Private"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotPrivate := 'h	| sum |	"@NOT Private"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodPrivateNew := 'h	| sum |	"@Private"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotPrivateNew := 'h	| sum |	"@NOT Private"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNew:= 'h	| sum |	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.			hMethodOverride:= 'h	| sum |	"@Override"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"5.1-------------------------------------------------------------------------------------------------------------"		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	GuyOmerTestsEX3 new removeAllLannisterSelectors.	"5.2-----------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodPrivateNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodPrivate] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Private method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'initalize 5/24/2017 19:58'!test_16CheckError6	|  hMethodNew hMethodNotFinal hMethodNotFinalNew hMethodOverride hMethodFinal hMethodFinalNew isException |		hMethodFinal := 'h	| sum |	"@Final"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodNotFinal := 'h	| sum |	"@NOT Final"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodFinalNew := 'h	| sum |	"@Final"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNotFinalNew := 'h	| sum |	"@NOT Final"	sum := 5. "@New"	^ (sum even).	"@RetType: Boolean."'.		hMethodNew:= 'h	| sum |	"@New"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.		hMethodOverride:= 'h	| sum |	"@Override"	sum := 5.	^ (sum even).	"@RetType: Boolean."'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"6.1-------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	"6.2-------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors.		isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodNotFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Cersei compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Tommen compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodFinalNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		isException := false.	[Cersei compile: hMethodNew] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: hMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		GuyOmerTestsEX3 new removeAllSelectorsOfClass: Cersei.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: hMethodFinal] on: AssertionFailure do:[ :e | "Should throw exception"	isException := true.	self assert:(e messageText = 'Cannot override Final method!!')].	self assert: isException.		"The methods will be deleted automatically"! !!GuyOmerTestsEX3 methodsFor: 'testing' stamp: 'guy 5/10/2017 17:17'!test_17AnotheRule	|   isException  kallllMethodAbstract kallllMethodOverride kallllMethod |	kallllMethod:= 'kallll	| sum |	"@Fork off"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.		kallllMethodAbstract := 'kallll	| sum |	"@Abstract"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.		kallllMethodOverride := 'kallll	| sum |	"@Override"	sum := 5.	^ (sum even).	"@NOTRetType: Boolean"'.	"------------------------------------------------------------------------------------------------------------------"	GuyOmerTestsEX3 new removeAllLannisterSelectors. 	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tywin compile: kallllMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.		isException := false.	[Tommen compile: kallllMethodOverride] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - no classes below"		isException := false.	[Tywin compile: kallllMethodAbstract] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - Tommen has '@Override' "		GuyOmerTestsEX3 new removeAllLannisterSelectors.	"------------------------------------------------------------------------------------------------------------------"	isException := false.	[Tommen compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - Tommen has '@Override' "		isException := false.	[Cersei compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Tommen has has nothing "		isException := false.	[Cersei compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Cersei sourceCodeAt: #'kallll')) includes: 'New') not. "Should NOT insert 'New' - because why should it ? "	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Tommen had no tags before compilation "		isException := false.	[Tywin compile: kallllMethod] on: AssertionFailure do:[ :e | "Should NOT throw exception"	isException := true].	self assert: isException not.	self assert: ((MyObject getTags: (Cersei sourceCodeAt: #'kallll')) includes: 'New'). "Should insert 'New' - Cersei had no tags before compilation "	self assert: ((MyObject getTags: (Tommen sourceCodeAt: #'kallll')) includes: 'New'). "Should still contain tag 'New'  "	"------------------------------------------------------------------------------------------------------------------"	"The methods will be deleted automatically"! !Class subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'private' stamp: 'initalize 5/23/2017 20:25'!instRespondsTo: aSymbol^ ((self class) classCanUnderstand:aSymbol).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: ''!!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/24/2017 20:27'!changeToAbstract:original|result|result := ''.(ReadStream on: original) do: [ :currentChar | 	result:=result,currentChar.	(currentChar=Character cr) ifTrue:[		result:=result,'MyObject throwAbstractMethodInvoked.'.		(self getTags:original) do:[:tag | result:=result,'"@',tag,'"'].		^result]	].! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/24/2017 13:59'!isMethod: aSymbol abstractIn: aClass
	"The method return true if the symbol which represent a method is an abstract method, and false otherwise"	| aSuperclass tagSet|	 aSuperclass := aClass.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false].	 [aSuperclass == nil]		whileFalse: 			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Abstract') ifTrue:[^true].			(tagSet includes:'Override') ifTrue:[^false]].			aSuperclass := aSuperclass superclass].	^false."[tags := MyObject getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tags includes:'@Abstract') ifTrue:[^true].			(tags includes:'@Override') ifTrue:[^false]."! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'rj 5/24/2017 02:03'!isMethod: aSymbol finalIn: aClass
	"The method return true if the symbol which represent a method is a private method, and false otherwise"	| aSuperclass tagSet|	 aSuperclass := aClass.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false].	 [aSuperclass == nil]		whileFalse: 			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Final') ifTrue:[^true].			(tagSet includes:'New') ifTrue:[^false]].			aSuperclass := aSuperclass superclass].	^false.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'rj 5/24/2017 02:01'!isMethod: aSymbol privateIn: aClass
	"The method return true if the symbol which represent a method is a private method, and false otherwise"	| aSuperclass tagSet|	 aSuperclass := aClass.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false].	 [aSuperclass == nil]		whileFalse: 			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Private') ifTrue:[^true].			(tagSet includes:'New') ifTrue:[^false]].			aSuperclass := aSuperclass superclass].	^false.! !!MyObject class methodsFor: 'AbstractHandling' stamp: 'initalize 5/23/2017 12:25'!new	(MyObject isAbstractClass:(self)) ifTrue:[self throwCanNotInitAbstract].	^(super new).! !!MyObject class methodsFor: 'TagsHelper' stamp: 'rj 5/19/2017 18:27'!char:ch existOnLine:line in:aString	"the method return a boolean if  ch exist on line in aString"	|lineNumber hadBeenCommented |	lineNumber:=1.	(ReadStream on: aString) do: [ :currentChar | 	(lineNumber=line and:[currentChar=ch ]) ifTrue:[ ^(hadBeenCommented:=true) ].	(lineNumber>line) ifTrue:[^false].	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"	^false.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'rj 5/19/2017 16:53'!extractTagContent: aTag
	"the method get aTag for example @SomeTag and return SomeTag"
	|tagSize tagContent|
	tagSize:= (aTag size).
	tagContent:= aTag copyFrom: 3 to: tagSize-1.
	^tagContent.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'initalize 5/23/2017 12:15'!findChar:ch in:aString	"the method return a the line number which ch first appears in aString"	|lineNumber |	lineNumber:=1.	(ReadStream on: aString) do: [ :currentChar | 	(currentChar=ch ) ifTrue:[ ^lineNumber ].	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"	^-1.! !!MyObject class methodsFor: 'TagsHelper' stamp: 'initalize 5/23/2017 15:38'!getTags:aString"a class method that get a String and returns a set of all the tags in that String without any special symbols, if no tags 	where found an empty Set is returned""example of such set will be:   {'New','Final','ArgsType'}"|regexString tagSet|tagSet:=Set new."defining all the tags to extract in Regex"regexString :='"@(Private|Override|New|Final|Abstract)"'."iterate over the string matches and add it to the set"(aString asString) regex: regexString matchesCollect: [:tag | tagSet add: (self extractTagContent:tag). ].regexString :='"@(RetType\:|ArgsTypes\:)'.(aString asString) regex: regexString matchesCollect: [:tag | tagSet add: (self extractTagContent:tag). ].^tagSet.! !!MyObject class methodsFor: 'Private' stamp: 'initalize 5/24/2017 20:27'!addPrivateCheck:methodText"the method inject privacy check to methodText"| toInject result parser methodName|	parser:= Parser new.	methodName:=parser parseSelector:methodText.		toInject:='			(			(	(thisContext client) class	)  includesLocalSelector: (#',methodName,')		)		 ifFalse:[			MyObject throwCanNotAccessMethod.			].'.			result:= self inject:toInject toMethod:methodText.		^result.! !!MyObject class methodsFor: 'Private' stamp: 'initalize 5/23/2017 20:19'!classCanUnderstand: aSymbol	| aSuperclass tagSet|	 aSuperclass := self.	((aSuperclass lookupSelector:aSymbol) = nil) ifTrue:[^false]. "RULE #1"	(MyObject isMethod:aSymbol abstractIn:self) ifTrue:[^false]. "RULE #2"	(aSuperclass includesSelector:aSymbol) ifTrue:[tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).	(tagSet includes:'Private') ifTrue:[^true]].  "part 2 of RULE #3"	 [aSuperclass == nil]		whileFalse: "Part 1+3 of RULE #3"			[(aSuperclass includesSelector:aSymbol) ifTrue:[			tagSet := self getTags:((aSuperclass sourceMethodAt:aSymbol) asString).			(tagSet includes:'Private') ifTrue:[^false].			(tagSet includes:'New') ifTrue:[^true]].			aSuperclass := aSuperclass superclass.		]. 		^true.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'rj 5/19/2017 15:32'!isAbstractClass: aClass(aClass allSelectors) do:[:sel | (MyObject isMethod:sel abstractIn:aClass) ifTrue:[^true]].^false.! !!MyObject class methodsFor: 'injection' stamp: 'rj 5/19/2017 18:27'!commentExistOnSecondLine:aString	"the method return a boolean if comment exist on second line of a method (aString)"	|lineNumber hadBeenCommented targetChar |	targetChar:=$".	lineNumber:=1.	(ReadStream on: aString) do: [ :currentChar | 			(lineNumber=2 and:[currentChar=targetChar ]) ifTrue:[ ^(hadBeenCommented:=true) ].	(lineNumber>2) ifTrue:[^false].	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"	^false.! !!MyObject class methodsFor: 'injection' stamp: 'rj 5/19/2017 18:27'!extractArgs: aString	"the method will extract the arguments to a orderedCollection of a method which will be returned."	| parser argsAsOrderedCollection |	parser:=Parser new.	"using the parser to get the aguments names"	argsAsOrderedCollection := parser parseParameterNames: aString.	^argsAsOrderedCollection.! !!MyObject class methodsFor: 'injection' stamp: 'rj 5/19/2017 19:36'!extractReturn:aString	"the method will extract the returned type from aString. if not found Nil will be returned"	| regexObj returnedValue  |	regexObj := '\^([^.]*)\.' asRegex.	regexObj search: (aString asString).	returnedValue := (regexObj  subexpression:2). 	^returnedValue.	! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/24/2017 19:11'!extractTypes: aString annotatedBy: annotation	"the method will extract the types of ArgTypes from a String"	|regexObj typesInString orderedTypes regexString|	"the ordeder of the types is imprtant so we save it in an orderedCollection"	orderedTypes := OrderedCollection new.	"@New"	"pulling all the types in argTypes via regex, including spaces"		regexString:='"@',annotation,'\:([^\.]+)\."'.	regexObj :=  regexString asRegex.	regexObj search: aString.	typesInString := (regexObj subexpression: 2) asString.	"adding the types to the collection which match with a word"	typesInString regex: '\w+' matchesCollect:[:each | orderedTypes add: each].		^orderedTypes.			! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/24/2017 19:47'!inject:code toMethod: aString	"the method return the method string with the injected code"	| result targetLine pipeExist commentExist blockExist |targetLine :=2.pipeExist :=self char:($|) existOnLine:targetLine in:aString.commentExist :=self char:($") existOnLine:targetLine in:aString.blockExist :=self char:($[) existOnLine:targetLine in:aString.(pipeExist and:[commentExist not] and:[blockExist not]) ifTrue:[targetLine:=targetLine+1]."now we have a good target, and we are need to look for the target line and inject it"result:=self inject:code toMethod:aString inLine:targetLine.^result.! !!MyObject class methodsFor: 'injection' stamp: 'initalize 5/23/2017 12:06'!inject:code toMethod: aString inLine: targetLine	"the method return the method string with the injected code"	|lineNumber wasAdded result|lineNumber:=1.wasAdded:=false.result:=''.(ReadStream on: aString) do: [ :currentChar | 	(lineNumber=targetLine and:[wasAdded=false]) ifTrue:[												result:=result,code. 												wasAdded:=true.												     ].	result:=result,currentChar.	(currentChar=Character cr) ifTrue:[lineNumber :=  lineNumber+1].	]."end of do block"^result.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:45'!addNewToSubclasses:selector in:aClass|methodCode tagSet|aClass allSubclassesDo:[:sub |	 (sub includesSelector:selector) ifTrue:[ "method exist on sub"										methodCode :=  ((sub sourceMethodAt:selector) asString). "get method code"										tagSet := self getTags:methodCode. 										((tagSet includes:'New') or:[tagSet includes:'Override']) ifFalse:[ "if any subclass does not have @Override or @New we add @New"										methodCode := (MyObject inject:'"@New"' toMethod:methodCode).										sub compile:methodCode] "end of trueBlock"				]."end of outer trueBlock"		]. "end of do block"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 20:30'!compile: text classified: category notifying: requestor	"the following method should:"	"check for errors"	"get the tags"	"change code"	|checkArgumentsEX checkReturnEx  tagSet orderedArgs orderedTypes returnValue returnTypes returnValueCollection argAnnotation returnAnnotation methodResult returnChar returnLine  methodName|		methodName:=self getMethodName:text.		tagSet:=MyObject getTags:text.		self validateBadTags:tagSet."validation of Bad Tags (ERROR 1)"		self validateMethodExistence:methodName WithTags:tagSet. "validate tags in heirarchy (ERROR 2,3)"	self validateInvalidHidingWithinMethod:methodName withTags:tagSet. "ERROR 4"		self validateOverrdingPrivateWithinMethod:methodName withTags:tagSet. "ERROR 5"		self validateOverrdingFinalWithinMethod:methodName withTags:tagSet. "ERROR 6"			"need to check for type errors"	tagSet isEmpty ifTrue:[							super compile: text classified: category notifying: requestor.							self addNewToSubclasses:methodName in:self. "last part in the hw"	]ifFalse:["tag set is not empty we should check and inject current method"							checkArgumentsEX:=''.							checkReturnEx:=''.							argAnnotation :='ArgsTypes'.							returnAnnotation := 'RetType'.							returnValueCollection := OrderedCollection new.							orderedArgs := self extractArgs:text.							orderedTypes:= self extractTypes:text annotatedBy: argAnnotation.							returnTypes:= self extractTypes:text annotatedBy: returnAnnotation.							returnValue := self extractReturn:text.							(returnValue isNil) ifTrue:[returnValue:='self'].																					(tagSet includes:argAnnotation) ifTrue:[checkArgumentsEX:=self validate:orderedArgs withTypes:orderedTypes].							checkArgumentsEX :=checkArgumentsEX,'.'.							"we add the return value to the collection to use the same validation method"							returnValueCollection add:returnValue.								(tagSet includes:returnAnnotation) ifTrue:[checkReturnEx:= self validate:returnValueCollection withTypes:returnTypes].								checkReturnEx := checkReturnEx,'.'.								"inject the return check to the method,as next line after delceration"								 returnChar:=$^.								"we need to find the line to inject the return value"								returnLine := self findChar:returnChar in:text.								methodResult:=text.								(returnLine>0) ifTrue:[									methodResult := (self inject: checkReturnEx toMethod: methodResult inLine:returnLine).								].							methodResult := (self inject: checkArgumentsEX toMethod: methodResult).							(tagSet includes:'Abstract') ifTrue:[methodResult:=self changeToAbstract: text].							(tagSet includes:'Private') ifTrue:[methodResult:=self addPrivateCheck: methodResult].							super compile: methodResult classified: category notifying: requestor.	]."tagSet is not Empty End" ! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 09:57'!getMethodName:methodText	"the method returns the method name of methodText"	| parser methodName|	parser:= Parser new.	methodName :=parser parseSelector:methodText.	^methodName.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:08'!isNewAfterAbstract:selector in:aClass	"Look down the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the subclass chain and try again.	Return nil if no method is found."	| sub  methodCode|	sub := aClass subclasses. "array of all subclasses"	(sub = #() ) ifTrue:[^false].	sub do:[:subClazz | 		(subClazz includesSelector:selector) ifTrue:[			methodCode :=  ((subClazz sourceMethodAt:selector) asString).			((MyObject getTags:methodCode) includes:'New') ifTrue:[^true] ifFalse:[^false].						] ifFalse:[			(self isNewAfterAbstract:selector in: subClazz) ifTrue:[^true]			].		].	^false.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 14:22'!isOverrideNext:selector in:aClass	| sub  methodCode|	sub := aClass subclasses. "array of all subclasses"	(sub = #() ) ifTrue:[^false].	sub do:[:subClazz | 		(subClazz includesSelector:selector) ifTrue:[ |tagSet|			methodCode :=  ((subClazz sourceMethodAt:selector) asString).			tagSet:=MyObject getTags:methodCode.			(tagSet includes:'Override') ifTrue:[^true] ifFalse:[(tagSet includes:'New') ifTrue:[^false]].			] ifFalse:[			(self isNewAfterAbstract:selector in: subClazz) ifTrue:[^true]			].		].	^false.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/23/2017 20:57'!lookDownSelector:selector	"Look down the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the subclass chain and try again.	Return nil if no method is found."	| lookDownClass |	lookDownClass := self.	[lookDownClass == nil]		whileFalse: 			[(lookDownClass includesSelector: selector)				ifTrue: [^ lookDownClass compiledMethodAt: selector].			lookDownClass := lookDownClass subclasses].	^ nil! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 20:27'!validate: orderedArgs withTypes: orderedTypes	"the method validates the ordered collection to be with the same kind of type,	 on compile time and runtime. the method will return the runtime check to inject"	|argCheckText  i |	(orderedTypes isNil) ifTrue:[self throwWrongType].	((orderedArgs size>0) and:[ orderedArgs size ~= orderedTypes size ] ) ifTrue:[ self throwWrongType.].	"arguments and the types are on the same size"	"inorder to check their types we will return a block check that will be activated on runtime"	i :=1.	argCheckText := '('.	[i<=orderedArgs size] whileTrue:[ | arg type |	arg := orderedArgs at:i.	type := orderedTypes at:i.	argCheckText:=argCheckText,'(',arg,' isKindOf:',type,') & '.	i:=i+1.	].	argCheckText:=argCheckText,'true)'. "to end concanting right, and to handle it to be default true"	argCheckText:=argCheckText,'ifFalse:[MyObject throwWrongType].'.	^argCheckText.! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 09:44'!validateBadTags:tagSet	((tagSet includes: 'Abstract') & (tagSet includes: 'Final'))  ifTrue: [self throwBadTags]. 	((tagSet includes: 'Override') & (((tagSet includes: 'New') | (tagSet includes: 'Private'))))  ifTrue: [self throwBadTags]. "ERROR 1"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:50'!validateInvalidHidingWithinMethod:methodName withTags:tagSet	"ERROR 4"	((self isMethod:methodName abstractIn:(self superclass)) and:[tagSet includes:'New']) ifTrue:[self throwCanNotHideAbstractMethod]. 	"Err 4 Pt2"	((tagSet includes: 'Abstract') and:[(self isNewAfterAbstract:methodName in:self)]) ifTrue:[self throwCanNotHideAbstractMethod]. ! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 13:57'!validateMethodExistence:methodName WithTags:tagSet	(((self superclass) lookupSelector:methodName) = nil) ifFalse:[((tagSet includes:'New')| (tagSet includes:'Override'))		 ifFalse:[self throwMethodAlreadyExist]]  "ERROR 2"	ifTrue:[((tagSet includes:'New')| (tagSet includes:'Override')) ifTrue:[self throwMethodDoesNotExist]].   "ERROR 3"! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:26'!validateOverrdingFinalWithinMethod:methodName withTags:tagSet	"Error 6"	(self isMethod:methodName finalIn:(self superclass)) ifTrue:[(tagSet includes:'Override') ifTrue:[self throwCanNotOverrideFinal]].	"Err 6 Pt2"	(tagSet includes: 'Final') ifTrue:[(self isOverrideNext:methodName in:self) ifTrue:[self throwCanNotOverrideFinal]].! !!MyObject class methodsFor: 'compiling' stamp: 'initalize 5/24/2017 16:24'!validateOverrdingPrivateWithinMethod:methodName withTags:tagSet	"ERROR 5"	(self isMethod:methodName privateIn:(self superclass)) ifTrue:[(tagSet includes:'Override') ifTrue:[self throwCanNotOverridePrivate]].	"Err 5 Pt2"	(tagSet includes: 'Private') ifTrue:[(self isOverrideNext:methodName in:self) ifTrue:[self throwCanNotOverridePrivate]].! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 20:25'!throwAbstractMethodInvoked	AssertionFailure signal:'Abstract method called!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:50'!throwBadTags	"the method thow bad tag tags error"	AssertionFailure signal: 'Bad Tags!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotAccessMethod	AssertionFailure signal: 'Cannot access method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotHideAbstractMethod	AssertionFailure signal: 'Cannot hide Abstract method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotInitAbstract	AssertionFailure signal: 'Cannot instantiate abstract class!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOverrideFinal	AssertionFailure signal:'Cannot override Final method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOverridePrivate	AssertionFailure signal: 'Cannot override Private method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:51'!throwCanNotOvverrideFinal	AssertionFailure signal: 'Cannot override Final method!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwMethodAlreadyExist	AssertionFailure signal:'Method already exists!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwMethodDoesNotExist	AssertionFailure signal: 'Method does not exist!!'.! !!MyObject class methodsFor: 'errors' stamp: 'initalize 5/24/2017 16:52'!throwWrongType	AssertionFailure signal: 'Wrong Type!!'.! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!A subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #DObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!DObject methodsFor: 'text' stamp: 'initalize 5/24/2017 16:48'!f:a^self.! !DObject subclass: #FObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!FObject methodsFor: 'text' stamp: 'initalize 5/24/2017 16:47'!f:a"@Override"^self.! !!FObject methodsFor: 'text' stamp: 'initalize 5/24/2017 13:56'!g..."@Override"... ^super f.! !MyObject subclass: #Tywin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Tywin methodsFor: 'as yet unclassified' stamp: 'initalize 5/24/2017 20:21'!g: x and: y			 	 	 	| privy |((x isKindOf:SmallInteger) & (y isKindOf:SmallInteger) & true)ifFalse:[self throwWrongType]...	"@NOT Private" ^(x*y). "@NOTRetType: Number"	"@ArgsTypes: SmallInteger, SmallInteger."! !Tywin subclass: #Cersei	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!Cersei subclass: #Tommen	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!